/****** NETAPI.H ************* Tarakanova I.R.  ******* 09/04/10 ***
*                                                                  *
*              Copyright (c) PANORAMA Group 1991-2010              *
*                      All Rights Reserved                         *
*                                                                  *
********************************************************************
*                                                                  *
*           ОПИСАНИЕ ФУНКЦИЙ ДОСТУПА К СЕТИ ОБЪЕКТОВ               *
*        ИНТЕРФЕЙС ДЛЯ ПРОГРАММ НА ЯЗЫКАХ C, PASCAL, BASIC         *
*                                                                  *
********************************************************************
*                                                                  *
*    Импортирование функций в Windows :                            *
*                                                                  *
*    // Загрузка библиотеки                                        *
*    HINSTANCE libInst = ::LoadLibrary("objnet.dll");              *
*                                                                  *
*    // Вызов функции                                              *
*    HSITE (WINAPI * lpfn_CrtObjNet)(HMAP hmap,                    *
*                                    TASKPARMEX * parm);           *
*    (FARPROC)lpfn_CrtObjNet = GetProcAddress(libInst,             *
*                                             "onCreateNetDlg");   *
*    HSITE sit =(*lpfn_CrtObjNet)(hmap,parm);                      *
*    ...                                                           *
*                                                                  *
*    long int (WINAPI * lpfn_SeekPathD)(HMAP hmap, HSITE site,     *
*                                       TASKPARMEX * parm,         *
*                                    HOBJ infobegin,HOBJ infoend); *
*    (FARPROC)lpfn_SeekPathD = GetProcAddress(libInst,             *
*                                             "onSeekPathDlg");    *
*    long int ret =(*lpfn_SeekPathD)(hmap,sit,parm,info1,info2);   *
*                                                                  *
*    ...                                                           *
*    // Выгрузка библиотеки                                        *
*    ::FreeLibrary(libInst);                                       *
*                                                                  *
*******************************************************************/

#ifndef NETAPI_H
#define NETAPI_H

#ifndef MAPTYPE_H
  #include "maptype.h"
#endif

// Коды семантик для логических связей между объектами сети:
#define SEMNETRIB       32812  // Номер объекта-ребра (для узла)
#define SEMNETKNOTFIRST 32813  // Номер объекта-узла первой точки (для ребра)
#define SEMNETKNOTLAST  32814  // Номер объекта-узла последней точки (для ребра)
#define SEMNETNUMBER    32815  // Номер сети
#define SEMNETTOOBJECT  32816  // Ссылка на объект листа
#define SEMNETVDIRECT   32817  // Скорость прямая (для ребра)
#define SEMNETVUNDIRECT 32818  // Скорость обратная (для ребра)
#define SEMNETCOSTRIB   32819  // Стоимость ребра
#define SEMNETRANKRIB   32820  // Ранг ребра

// Коды объектов для построения и работы с сетью
// 5557   // Ребро сети двустороннее
// 5558   // Узел сети
// 5559   // Маршрут
// 5560   // Ошибочная точка
// 5561   // Номер опорной точки
// 5562   // Ребро сети одностороннее


typedef long int  HGRAPH;  // ИДЕНТИФИКАТОР ГРАФА СЕТИ
                           // (УКАЗАТЕЛЬ НА TGraph)


#ifdef __cplusplus
extern "C"
{
#endif

// -----------------------------------------------------------------------------
// Построение геометрической сети объектов
// hmap - идентификатор открытой векторной карты
// parm - описание параметров задачи (см.maptype.h)
// На карте предварительно должны быть выделены программными средствами
// (напр. функцией mapSetSiteSeekSelect(...)) объекты для построения сети
// (напр. дорожная сеть)
// В функции вызывается диалог "Построение сети", в котором задаются:
// имя выходного файла, классификатор (service.rsc),вид объектов
// Классификатор  service.rsc содержит объекты: узел сети, ребро сети и
// обязательную семантику, необходимую для работы с сетью  (SEMNETRIB ...)
// Из диалога построения для заполнения некоторых семантик вызывается диалог
// "Настройка параметров для построения сети", который активизируется по
// соответствующей кнопке
//   Диалог предназначен для заполнения семантики ребер и представляет собой
//   таблицу с названиями и кодами выделенных объектов, по которым строится сеть
//   Семантика УРанг объектаУ заполняется пользователем числовыми значениями
//   Значения  скорости можно выбрать из списка числовых характеристик исходного
//   объекта  или ввести с клавиатуры
// При успешном выполнении возвращает идентификатор пользовательской карты
// с построенной сетью
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
HSITE WINAPI onCreateNetDlg(HMAP hmap, TASKPARMEX * parm);


// -----------------------------------------------------------------------------
// Построение геометрической сети объектов
// hmap - идентификатор открытой векторной карты
// parm - описание параметров задачи (см.maptype.h)
// namesit - имя выходного файла
// namersc - классификатор (должен содержать объекты: узел сети, ребро сети и
// обязательные семантики (SEMNETRIB, SEMNETKNOTFIRST ...) )
// flag - управление диалогом  "Построение сети" (0- не вызывать диалог, 1 - вызывать)

HSITE WINAPI onCreateNetDlgEx(HMAP hmap, TASKPARMEX * parm,
                              char * namesit, char * namersc, int flag);


// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя узлами сети
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// pointbegin - начальный узел (идентификатор объекта карты в памяти)
// pointend - конечный узел (идентификатор объекта карты в памяти)
// В функции вызывается диалог "Параметры построения минимального пути", в котором
// устанавливаются метод построения (длина или время,в последнем случае ребра
// должны иметь семантику "Скорость") и фильтр по семантикам ребер
// По окончании работы функции выдается результирующий диалог "Список объектов",
// в который записываются реальные объекты карты и протяженность пути по каждому объекту
// На пользовательской картe будут выделены ребра,которые составляют минимальный маршрут
// Число выделенных объектов определяется функцией mapTotalSeekObjectCount(seekapi.h)
// Получить идентификатор выделенного объекта можно используя функцию mapTotalSeekObject(seekapi.h)
// Возвращает: номер объекта (mapObjectKey), если объект маршрут создавался
//            - 1, если объект маршрут не создавался
//              0, при ошибке
// -----------------------------------------------------------------------------
long int WINAPI onSeekPathDlg(HMAP hmap, HSITE site, TASKPARMEX * parm,
                              HOBJ infobegin,HOBJ infoend);


// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя узлами сети без вызова диалогов
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// pointbegin - начальный узел(идентификатор объекта карты в памяти)
// pointend - конечный узел(идентификатор объекта карты в памяти)
// methodseek - метод построения (0 - длина, 1- время)
// speed - средняя скорость (км/ч)(если methodseek = 1 и значения семантики
// "Скорость" не установлены)
// На пользовательской картe будут выделены ребра,которые составляют минимальный маршрут
// Число выделенных объектов определяется функцией mapTotalSeekObjectCount(seekapi.h)
// Получить идентификатор выделенного объекта можно используя функцию mapTotalSeekObject(seekapi.h)
// Возвращает: номер объекта (mapObjectKey), если объект маршрут создавался
//            - 1, если объект маршрут не создавался
//              0, при ошибке
// -----------------------------------------------------------------------------
long int WINAPI onSeekPath(HMAP hmap, HSITE site, TASKPARMEX * parm,
                           HOBJ infobegin,HOBJ infoend,
                           long int methodseek, double speed); 

// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя узлами сети без вызова диалогов
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// object - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь.
// pointbegin - начальный узел(идентификатор объекта карты в памяти)
// pointend - конечный узел(идентификатор объекта карты в памяти)
// methodseek - метод построения (0 - длина, 1- время)
// speed - средняя скорость (км/ч)(если methodseek = 1 и значения семантики
// "Скорость" не установлены)
// Возвращает: -1, если путь найден
//              0, при ошибке
// -----------------------------------------------------------------------------
long int WINAPI onSeekPathCreateObject(HMAP hmap, HSITE site,
                                       TASKPARMEX * parm,HOBJ object,
                                       HOBJ infobegin,HOBJ infoend,
                                       long int methodseek, double speed);


// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя точками
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// На картe создается условный объект - минимальный маршрут
// Возвращает: номер объекта (mapObjectKey), если объект маршрут создавался
//            - 1, если объект маршрут не создавался
//              0, при ошибке
// -----------------------------------------------------------------------------
// 03/09/07
long int WINAPI onSeekPathDlgByPoint(HMAP hmap, HSITE site,HOBJ info,TASKPARMEX * parm,
                                     DOUBLEPOINT * point1,DOUBLEPOINT * point2);


// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя точками
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// Возвращает: -1, если путь найден
//              0, при ошибке
// -----------------------------------------------------------------------------
// 22/09/08
long int WINAPI onSeekPathByPoint(HMAP hmap, HSITE site, HOBJ info, TASKPARMEX * parm,
                                  DOUBLEPOINT * point1,DOUBLEPOINT * point2);

// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя точками с учетом одностороннего
// движения и исключением ребер (аварийных участков)
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// select - контекст условий поиска (должен содержать ребра, которые исключаются из поиска мин. пути)
// foneway - флаг одностороннего движения (0 - не учитывать, 1- учитывать)
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// Возвращает: -1, если путь найден
//              0, при ошибке
// -----------------------------------------------------------------------------
// 11/01/09
long int WINAPI onSeekPathByPointEx(HMAP hmap, HSITE site, HOBJ info, TASKPARMEX * parm,
                                    DOUBLEPOINT * point1, DOUBLEPOINT * point2,
                                    HSELECT select, int foneway);
                                            

// -----------------------------------------------------------------------------
// Нахождение в сети ребер, расположенных на расстоянии менее заданного от
// указанного узла (построение графа удаленности)
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью, т.е. на карте должны быть
// объекты узлы сети с обязательными семантиками: номер сети и ссылка на ребро
// сети, и ребра с семантиками: номер первого и последнего узлов для данного
// ребра, ссылка на объект карты и номер сети
// info -  узел сети (идентификатор объекта карты в памяти)
// distance - расстояние в метрах
// На пользовательской карте будут выделены ребра, расположенные  на расстоянии,
// менее distance от info
// Число выделенных объектов определяется функцией mapTotalSeekObjectCount(seekapi.h)
// Получить идентификатор объекта можно используя функцию mapTotalSeekObject(seekapi.h)
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onDistFromKnot(HMAP hmap, HSITE site, TASKPARMEX * parm,
                               HOBJ info, double distance);

// -----------------------------------------------------------------------------
// Получить ближайший узел сети к указанной точке
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// info - идентификатор объекта карты в памяти
// point - координаты точки в метрах  в системе карты
// Пример использования:
//  - создаем объект
//    HOBJ hobj = mapCreateSiteObject(hmap,site,IDDOUBLE2,0);
//  - находим ближайший узел к точке point и записываем в hobj
//    long int ret = onGetNodeByPoint(hmap,site,hobj, point);
//  - вызываем функцию работы с сетью
//    if (ret)
//        onDistFromKnot(hmap,site,parm,hobj,20);
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onGetNodeByPoint(HMAP hmap, HSITE site,
                                 HOBJ info, DOUBLEPOINT * point);


// -----------------------------------------------------------------------------
// Получить ближайший линейный объект (ребро) к указанной точке
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// info - идентификатор объекта карты в памяти
// point - координаты точки в метрах  в системе карты
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onGetRibByPoint(HMAP hmap, HSITE site,
                                HOBJ info, DOUBLEPOINT * point);

// -----------------------------------------------------------------------------
// Вычисление минимального пути между точками (узлами сети)
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// parm - описание параметров задачи (см.maptype.h)
// array - адрес массива координат опорных точек,
//         размер массива равен count
// count - количество точек для построения минимального пути
// Расчеты производятся по ближайшим к точкам узлам сети
// В функции вызывается диалог "Параметры построения минимального пути", в котором
// устанавливаются метод построения (длина или время,в последнем случае ребра
// должны иметь семантику "Скорость") и фильтр по семантикам ребер
// По окончании работы функции выдается результирующий диалог "Порядок обхода точек",
// в который записываются номера точек в том порядке, в котором путь прохождения по ним минимален,
// протяженность маршрута между соседней парой точек, общая длина пути.
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onMinimalPath(HMAP hmap, HSITE site, TASKPARMEX * parm,
                              DOUBLEPOINT * arraypoint,long int count);

// -----------------------------------------------------------------------------
// Вычисление минимального пути между точками (узлами сети)
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// parm - описание параметров задачи (см.maptype.h)
// arraypoint - адрес массива координат (в метрах на местности) опорных точек,
//              размер массива равен count
// arraynumber - адрес массива с номерами точек (для результатов),
//               размер массива равен count
// count - количество точек для построения минимального пути
// flagoneway - флаг одностороннего движения (0 - не учитывать, 1 - учитывать)
// flagreturn - флаг возврата в первую точку (0 - не возвращаться, 1 - возвращаться)
// flagcalc - метод расчета (0 - по длине, 1- по времени)
// Расчеты производятся по ближайшим к точкам узлам сети
// В массив arraynumber будут записаны номера точек, которые определяют порядок обхода
// Возвращает общую длину пути
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
// 25/12/08
double WINAPI onMinimalPathEx(HMAP hmap, HSITE site, TASKPARMEX * parm,
                              DOUBLEPOINT * arraypoint,int * arraynumber,
                              long int count, int flagoneway, int flagreturn, int flagcalc);



//03/06/08
// -----------------------------------------------------------------------------
// Редактирование сети - удаление узлов
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// info - идентификатор объекта, который нужно удалить
// Узел для удаления должен иметь ссылки на четыре ребра
// Если у противолежащих ребер совпадает семантика, то узел удаляется,если нет -
// удаляются семантики  и для каждой пары ребер создается свой узел
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onEditDeleteNode(HMAP hmap, HSITE site,TASKPARMEX *parm,
                                 HOBJ info);

// -----------------------------------------------------------------------------
// Редактирование сети - добавление узлов
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// info1 и info2 - идентификаторы объектов, на пересечении которых нужно добавить узел
// Функция обратная к  onEditDeleteNode(...)
// Добавляет удаленные узлы и согласовывает семантики
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onEditAddNode(HMAP hmap, HSITE site,TASKPARMEX *parm,
                              HOBJ info1,HOBJ info2);


// -----------------------------------------------------------------------------
// Редактирование сети - распараллеливание дорог
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// Функция добавляет в сеть параллельные участки на перекрестках дорог
// info - идентификатор объекта(узла на перекрестке)
// Узел должен иметь ссылки на четыре ребра
// Функция создает дополнительные узлы сети и ребра сети односторонние
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onEditRoad(HMAP hmap, HSITE site,TASKPARMEX *parm,
                           HOBJ info);

// -----------------------------------------------------------------------------
// Редактирование сети - создание съездов и разворотов
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с построенной сетью
// info1 и info2 - идентификаторы объектов (ребер),должны иметь общий узел и быть односторонними
// В качестве info1 и info2 рекомендуется использовать результаты функции onEditRoad(...)
// Создает объекты - ребра в виде дуг и удаляет общий узел
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onEditCreateArc(HMAP hmap, HSITE site,TASKPARMEX *parm,
                                HOBJ info1,HOBJ info2);




                                        
 /*********************************************************
 *                                                        *
 *                  ФУНКЦИИ HGRAPH                        *
 *                                                        *
 *********************************************************/
// 28/04/09
// -----------------------------------------------------------------------------
// Открытие списка графов
// hmap - идентификатор открытой векторной карты
// site - пользовательская карта с сетью
// Идентификатор пользовательской карты с сетью  можно получить,
// используя функцию onGetGraphSiteIdent(...)
// При успешном выполнении возвращает идентификатор графа сети
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
HGRAPH WINAPI onOpenGraphEx(HMAP hmap, HSITE site);


// -----------------------------------------------------------------------------
// Закрыть список графов
// hgraph - идентификатор графа сети
// -----------------------------------------------------------------------------
long int WINAPI onCloseGraph(HGRAPH hgraph);


//-----------------------------------------------------------------
// Определить sit с сетью
// hmap - идентификатор открытой векторной карты
// При успешном выполнении возвращает идентификатор пользовательской
// карты с графом сети (если карт с сетью несколько, возвращается идентификатор
// первой карты с сетью)
// При ошибке возвращает 0
//-----------------------------------------------------------------
HSITE WINAPI onGetGraphSiteIdent(HMAP hmap);


// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя узлами сети
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// infobegin - начальный узел (идентификатор объекта карты в памяти)
// infoend - конечный узел (идентификатор объекта карты в памяти)
// В функции вызывается диалог "Параметры построения минимального пути", в котором
// устанавливаются метод построения (длина или время,в последнем случае ребра
// должны иметь семантику "Скорость") и фильтр по семантикам ребер
// По окончании работы функции выдается результирующий диалог "Список объектов",
// в который записываются реальные объекты карты и протяженность пути по каждому объекту
// На пользовательской картe будут выделены ребра,которые составляют минимальный маршрут
// Число выделенных объектов определяется функцией mapTotalSeekObjectCount(seekapi.h)
// Получить идентификатор выделенного объекта можно используя функцию mapTotalSeekObject(seekapi.h)
// Возвращает: номер объекта (mapObjectKey), если объект маршрут создавался
//            - 1, если объект маршрут не создавался
//              0, при ошибке
// -----------------------------------------------------------------------------
long int WINAPI onSeekPathDlgGraph(HMAP hmap,HGRAPH hgraph, TASKPARMEX * parm,
                                   HOBJ infobegin,HOBJ infoend);

// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя узлами сети без вызова диалогов
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// pointbegin - начальный узел(идентификатор объекта карты в памяти)
// pointend - конечный узел(идентификатор объекта карты в памяти)
// methodseek - метод построения (0 - длина, 1- время)
// speed - средняя скорость (км/ч)(если methodseek = 1 и значения семантики
// "Скорость" не установлены)
// На пользовательской картe будут выделены ребра,которые составляют минимальный маршрут
// Число выделенных объектов определяется функцией mapTotalSeekObjectCount(seekapi.h)
// Получить идентификатор выделенного объекта можно используя функцию mapTotalSeekObject(seekapi.h)
// Возвращает: номер объекта (mapObjectKey), если объект маршрут создавался
//            - 1, если объект маршрут не создавался
//              0, при ошибке
// -----------------------------------------------------------------------------

long int WINAPI onSeekPathGraph(HMAP hmap,HGRAPH hgraph, TASKPARMEX * parm,
                                HOBJ infobegin,HOBJ infoend,
                                long int methodseek, double speed);

//13/07/09
// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя узлами сети без вызова диалогов
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// object - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь.
// infobegin - начальный узел(идентификатор объекта карты в памяти)
// infoend - конечный узел(идентификатор объекта карты в памяти)
// select - контекст условий поиска, предварительно созданный функцией
// mapCreateSiteSelectContext(...), для размещения результатов (в select записываются
// дуги, которые составляют минимальный путь)
// methodseek - метод построения (0 - длина, 1- время)
// speed - средняя скорость (км/ч)(если methodseek = 1 и значения семантики
// "Скорость" не установлены)
// При ошибке возвращает 0
// -----------------------------------------------------------------------------

long int WINAPI onSeekPathGraphSelect(HMAP hmap,HGRAPH hgraph,HOBJ object,
                                      HOBJ infobegin,HOBJ infoend,HSELECT select,
                                      long int methodseek, double speed);

// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя узлами сети без вызова диалогов
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// object - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь.
// pointbegin - начальный узел(идентификатор объекта карты в памяти)
// pointend - конечный узел(идентификатор объекта карты в памяти)
// methodseek - метод построения (0 - длина, 1- время)
// speed - средняя скорость (км/ч)(если methodseek = 1 и значения семантики
// "Скорость" не установлены)
// Возвращает: -1, если путь найден
//              0, при ошибке
// -----------------------------------------------------------------------------

long int WINAPI onSeekPathCreateObjectGraph(HMAP hmap,HGRAPH hgraph, TASKPARMEX * parm,
                                            HOBJ object,HOBJ infobegin,HOBJ infoend,
                                            long int methodseek, double speed);

// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя точками
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// На картe создается условный объект - минимальный маршрут
// Возвращает: номер объекта (mapObjectKey), если объект маршрут создавался
//            - 1, если объект маршрут не создавался
//              0, при ошибке
// -----------------------------------------------------------------------------
long int WINAPI onSeekPathDlgByPointGraph(HMAP hmap,HGRAPH hgraph, HOBJ info, TASKPARMEX * parm,
                                          DOUBLEPOINT * point1,DOUBLEPOINT * point2);

// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя точками
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// Возвращает: -1, если путь найден
//              0, при ошибке
// -----------------------------------------------------------------------------
long int WINAPI onSeekPathByPointGraph(HMAP hmap,HGRAPH hgraph, HOBJ info, TASKPARMEX * parm,
                                       DOUBLEPOINT * point1,DOUBLEPOINT * point2);


//13/07/09
// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя точками
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onSeekPathByPointGraphEx(HMAP hmap,HGRAPH hgraph, HOBJ info,
                                         DOUBLEPOINT * point1,DOUBLEPOINT * point2);


// -----------------------------------------------------------------------------
// Определение кратчайшего расстояния между двумя точками с учетом одностороннего
// движения и исключением ребер (аварийных участков)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// point1 - начальная точка в метрах на местности
// point2 - конечная точка в метрах на местности
// select - контекст условий поиска (должен содержать ребра, которые исключаются из поиска мин. пути)
// одностороннее движение учитывается всегда
// Путь определяется от точки на ближайшем ребре к point1 до точки на ближайшем
// ребре к point2
// Возвращает: -1, если путь найден
//              0, при ошибке
// -----------------------------------------------------------------------------
long int WINAPI onSeekPathByPointExGraph(HMAP hmap,HGRAPH hgraph, HOBJ info,
                                         TASKPARMEX * parm,DOUBLEPOINT * point1,
                                         DOUBLEPOINT * point2,HSELECT select); 


//09/04/10
// -----------------------------------------------------------------------------
// Получить количество дуг маршрута
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// infobegin - начальный узел(идентификатор объекта карты в памяти)
// infoend - конечный узел(идентификатор объекта карты в памяти)
// Возвращает: количество дуг маршрута от infobegin до infoend
// -----------------------------------------------------------------------------
long int WINAPI onGetCountRib(HMAP hmap,HGRAPH hgraph,
                              HOBJ infobegin,HOBJ infoend);


// -----------------------------------------------------------------------------
// Получить массив номеров дуг маршрута от infobegin до infoend
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// infobegin - начальный узел(идентификатор объекта карты в памяти)
// infoend - конечный узел(идентификатор объекта карты в памяти)
// arrayrib - адрес массива для номеров дуг,  размер массива равен count
// count - количество дуг, д.б. получены функцией onGetCountRib(...)
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onGetArrayRib(HMAP hmap,HGRAPH hgraph,
                              HOBJ infobegin,HOBJ infoend,
                              int * arrayrib,long int count);

                              
// -----------------------------------------------------------------------------
// Нахождение в сети ребер, расположенных на расстоянии менее заданного от
// указанного узла (построение графа удаленности)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// info -  узел сети (идентификатор объекта карты в памяти)
// distance - расстояние в метрах
// На пользовательской карте будут выделены ребра, расположенные  на расстоянии,
// менее distance от info
// Число выделенных объектов определяется функцией mapTotalSeekObjectCount(seekapi.h)
// Получить идентификатор объекта можно используя функцию mapTotalSeekObject(seekapi.h)
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onDistFromKnotGraph(HMAP hmap,HGRAPH hgraph, TASKPARMEX * parm,
                                    HOBJ info, double distance);


//13/07/09
// -----------------------------------------------------------------------------
// Нахождение в сети ребер, расположенных на расстоянии менее заданного от
// указанного узла (построение графа удаленности)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// select - контекст условий поиска, предварительно созданный функцией
// mapCreateSiteSelectContext(...), для размещения результатов (в select записываются
// дуги, которые составляют граф удаленности)
// info -  узел сети (идентификатор объекта карты в памяти)
// distance - расстояние в метрах
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onDistFromKnotGraphEx(HMAP hmap,HGRAPH hgraph,HSELECT select,
                                      HOBJ info, double distance);

// -----------------------------------------------------------------------------
// Вычисление минимального пути между точками (узлами сети)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// parm - описание параметров задачи (см.maptype.h)
// array - адрес массива координат опорных точек,
//         размер массива равен count
// count - количество точек для построения минимального пути
// Расчеты производятся по ближайшим к точкам узлам сети
// В функции вызывается диалог "Параметры построения минимального пути", в котором
// устанавливаются метод построения (длина или время,в последнем случае ребра
// должны иметь семантику "Скорость") и фильтр по семантикам ребер
// По окончании работы функции выдается результирующий диалог "Порядок обхода точек",
// в который записываются номера точек в том порядке, в котором путь прохождения по ним минимален,
// протяженность маршрута между соседней парой точек, общая длина пути.
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onMinimalPathGraph(HMAP hmap,HGRAPH hgraph, TASKPARMEX * parm,
                                   DOUBLEPOINT * arraypoint,long int count);

// -----------------------------------------------------------------------------
// Вычисление минимального пути между точками (результаты отображаются на tempsite)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// parm - описание параметров задачи (см.maptype.h)
// array - адрес массива координат (в метрах на местности) опорных точек,
//         размер массива равен count
// count - количество точек для построения минимального пути
// Расчеты производятся по ближайшим к точкам узлам сети
// В функции вызывается диалог "Параметры построения минимального пути", в котором
// устанавливаются метод построения (длина или время,в последнем случае ребра
// должны иметь семантику "Скорость") и фильтр по семантикам ребер
// По окончании работы функции выдается результирующий диалог "Порядок обхода точек",
// в который записываются номера точек в том порядке, в котором путь прохождения по ним минимален,
// протяженность маршрута между соседней парой точек, общая длина пути.
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onMinimalPathSiteGraph(HMAP hmap,HGRAPH hgraph, TASKPARMEX * parm,
                                       HSITE tempsite,DOUBLEPOINT * arraypoint,
                                       long int count);

// -----------------------------------------------------------------------------
// Вычисление минимального пути между точками (узлами сети)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraph(...)
// parm - описание параметров задачи (см.maptype.h)
// arraypoint - адрес массива координат (в метрах)  опорных точек,
//              размер массива равен count
// arraynumber - адрес массива с номерами точек (для результатов),
//               размер массива равен count
// count - количество точек для построения минимального пути
// одностороннее движение учитывается всегда
// flagreturn - флаг возврата в первую точку (0 - не возвращаться, 1 - возвращаться)
// flagcalc - метод расчета (0 - по длине, 1- по времени)
// Расчеты производятся по ближайшим к точкам узлам сети
// В массив arraynumber будут записаны номера точек, которые определяют порядок обхода
// Возвращает общую длину пути
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
double WINAPI onMinimalPathExGraph(HMAP hmap,HGRAPH hgraph, TASKPARMEX * parm,
                                   DOUBLEPOINT * arraypoint,int * arraynumber,
                                   long int count,int flagreturn, int flagcalc);

//13/07/09
// -----------------------------------------------------------------------------
// Вычисление минимального пути между точками (узлами сети)
// hmap - идентификатор открытой векторной карты
// hgraph - идентификатор графа сети, предварительно должен быть открыт функцией
// onOpenGraphEx(...)
// info - идентификатор объекта в памяти,
//        предварительно созданного функцией mapCreateObject()
//        или mapCreateSiteObject(),
//        в котором будет размещен результат - минимальный путь
// arraypoint - адрес массива координат (в метрах)  опорных точек,
//              размер массива равен count
// arraynumber - адрес массива с номерами точек (для результатов),
//               размер массива равен count
// count - количество точек для построения минимального пути
// одностороннее движение учитывается всегда
// flagreturn - флаг возврата в первую точку (0 - не возвращаться, 1 - возвращаться)
// flagcalc - метод расчета (0 - по длине, 1- по времени)
// Расчеты производятся по ближайшим к точкам узлам сети
// В массив arraynumber будут записаны номера точек, которые определяют порядок обхода
// При ошибке возвращает 0
// -----------------------------------------------------------------------------
long int WINAPI onMinimalPathExGraphEx(HMAP hmap, HGRAPH hgraph, HOBJ info,
                                     DOUBLEPOINT * arraypoint, int * arraynumber,
                                     long int count, int flagreturn, int flagcalc);
#ifdef __cplusplus
}       // extern "C"
#endif

#endif  // NETAPI_H
